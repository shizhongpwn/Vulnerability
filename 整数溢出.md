# 整数溢出

> 感谢sakura师傅提供的心得笔记。学到了

Case1:

~~~c
u_char *make_table(unsigned int width, unsigned int height, u_char *init_row) {
    unsigned int n;
    int i;
    u_char *buf;
    n = width * height; //任意输入两个unsigned int类型的参数，相乘的结果保留在一个unsigned int类型中导致整数溢出
    //计算方式：将width设置为0x400，height设置为0x1000001，相乘后溢出得到1024，0x400000400%(2**32)=1024
    buf = (char *)malloc(n);
    if (!buf) {
        return NULL;
    }
    for (int j = 0; j < height; ++j) {
        memcpy(&buf[i*width], init_row, width);
    }
    return buf;
}
~~~

Case2:

~~~c
u_int nresp; 
...
nresp = packet_get_int(); 
if (nresp > 0) {
    response = xmalloc(nresp * sizeof(char*));//如果将nresp的值设置的足够大，就会产生溢出，进而malloc一个较小的值。 
    for (i = 0; i < nresp; i++)
        response[i] = packet_get_string(NULL); 
packet_check_eom();
~~~

## 减法下溢

~~~
unsigned int a; 
a=0x10;
a-=0x30;
~~~

~~~
0000 0000 0000 0000 0000 0000 0001 0000 - 
0000 0000 0000 0000 0000 0000 0011 0000 = 
1111 1111 1111 1111 1111 1111 1110 0000
~~~

这就导致结果为0xffffffe0.

Case1:

~~~c
struct header {
	unsigned int length;
	unsigned int message_type;
};
char *read_packet(int sockfd)
{
	int n;
	unsigned int length;
	struct header hdr;
	static char buffer[1024];
	if(full_read(sockfd, (void *)&hdr, sizeof(hdr))<=0){
		error("full_read: %m");
		return NULL;
	}
	length = ntohl(hdr.length);//意味着从网络端接收length长度
	if(length > (1024 + sizeof(struct header) - 1)){
        error("not enough room in buffer\n");
		return NULL;
	}
	if(full_read(sockfd, buffer,
			length-sizeof(struct header))<=0) //如果之前的length长度被设置为很小的值，那么此时的减法下溢就可能导致该结果产生一个很大的值。
	{
		error("read: %m");
		return NULL;
	}
	buffer[sizeof(buffer)-1] = '\0';
	return strdup(buffer);
}
~~~

## 带符号整数边界

带符号整数的溢出一般来源于符号位的变化。

例如将一个正数溢出到0x80000000以上来变成一个负数，或者将一个负数溢出到0x80000000以下来变成一个正数，从而突破符号边界。

Case1:

~~~c
#define MAXCHARS 1024
char *read_data(int sockfd)
{
    char *buf;
	int length = network_get_int(sockfd);
	if(!(buf = (char *)malloc(MAXCHARS)))
		die("malloc");
	if(length < 0 || length + 1 >= MAXCHARS){
		free(buf);
        die("bad length");
	}
	if(read(sockfd, buf, length) <= 0){
            free(buf);
            die("read");
	}
	return buf;
}
~~~

该case中length可由网络获得，如果其被设置为0x7fffffff，那么length < 0可绕过，同时length + 1也可以绕过，因为0x7fffffff+1=0x80000000，导致其变成了一个负数。但是下面的read系统调用的length是一个无符号整数，这就导致有了一个几乎不限制长度的输入。

Case2:openssl 0.9.6

~~~c
c.inf=ASN1_get_object(&(c.p),&(c.slen),&(c.tag),&(c.xclass), len-off);
...
{
    /* suck in c.slen bytes of data */ 
    want=(int)c.slen;
    if (want > (len-off))
    {
        want-=(len-off);
        
        if (!BUF_MEM_grow(b,len+want)) {
            ASN1err(ASN1_F_ASN1_D2I_BIO, ERR_R_MALLOC_FAILURE);
            goto err; 
        }
~~~

want是一个有符号整数，len代表的是已经分配的内存，off代表的是已经使用的内存，这段代码的含义在于如果需要的内存大于剩余的内存那么就进行通过BUF_MEM_grow来进行内存分配，这里的关键在于want-(len-off)，但是在下面的代码中出现了want+len，那么如果want=0x7fffffff，len=200，off=50，则在进行加法运算的时候len+want的结果就变成了一个负数，结合BUF_MEM_gouw函数的实现（会将它的长度参数和之前已经分配的空间大小作比较，如果小于，则不会重新进行内存分配。），我们发现会造成内存重分配绕过，进而造成堆溢出。

## 类型转换

### 整数类型：保值

在进行类型转换的过程中，如果新的类型可以表示所有旧类型可能的值，那么这种转换就是保值的。这种情况下，转换的结果不会导致值发生任何变化或丢失。

### 整数类型：扩展

当你将一个较窄类型转换为另一个更宽的类型时，机器会按位将旧的变量复制到新的变量，然后将其他的高位设为0或者1.

* 如果源类型是无符号的，那么就会使用零扩展的方式，将宽类型的剩余高危全部设为0.
* 如果源类型是有符号的，那么就会采用符号位扩展，将宽类型剩余未使用位设为源类型中符号位的值。

### 整数类型：截断

当将一个宽类型转换为窄类型时，机器只会使用一种机器：截断(truncation)。宽类型中与窄类型不匹配的位会被全部舍去。

同时，所有的收缩转换都是变值转换，因为在转换的过程中精度丢失了。

### 整数类型：带符号与无符号

相同宽度的带符号和无符号数之间的转换，在位级别上不会发生变化，但是这样的转换是变值的。

## 算术类型转换规则

1. 浮点优先

## 类型转换漏洞

### signed/Unsigned转换

Case1:

~~~c
int copy(char *dst, char *src, unsigned int len)
{
    while (len--)
    *dst++ = *src++;
}
~~~

如果第三个参数传入的是无符号整数，那么就会导致类型转换

~~~c
int f = -1;
copy(mydst, mysrc, f);
~~~

copy()函数将会得到一个非常大的len。几乎所有的libc例行程序都将大小参数的类型定为size_t，这是一种和指针长度相等的无符号类型。这也是为什么永远不要将一个负长度的参数传入libc函数,例如snprintf(), strncpy(), memcpy(), read(), 或者strncat()

* 审计技巧：函数使用size_t或者unsigned整数作为长度参数，但是参数可以被用户控制，传入一个负值。

  适合review的函数包括read()、recvfrom()、memcpy()、memset()、bcopy()、snprintf()、strncat()、strncpy()和malloc()。如果用户传入一个负值，那么函数会将其解释为一个极大值，可能导致溢出漏洞。

### Sign_Extension

从窄的带符号类型转换为宽的无符号类型，编译器会生成汇编指令执行符号位扩展，对象的值可能会变。

Case1:

~~~c
char len;
len = get_len_field();
snprintf(dst, (unsigned int)len, "%s", src)
~~~

符号位扩展发生在char到unsigned int的类型转换过程中，如果len是一个负值，那么在符号扩展之后len就是一个很大的值。

**程序员们总是忘记他们使用的char和short类型是有符号的。**

Case2:

~~~c
char *indx;
int count;
char nameStr[MAX_LEN]; //256
...
memset(nameStr, '\0', sizeof(nameStr)); 
...
indx = (char *)(pkt + rr_offset); 
count = (char)*indx;
while (count){
    if (strlen(nameStr) + count < ( MAX_LEN - 1) ){
        (char *)indx++;
        strncat(nameStr, (char *)indx, count); //count在这里被当做了size_t类型，这就导致一个负数被当做了一个很大的正数使用，导致溢出
        indx += count;
        count = (char)*indx;
        strncat(nameStr, ".", sizeof(nameStr) - strlen(nameStr));
    } else {
        fprintf(stderr, "Alert! Someone is attempting "
        "to send LONG DNS packets\n");
        count = 0; 
    }
}
nameStr[strlen(nameStr)-1] = '\0';
~~~

 这个case其实漏洞隐藏的十分好，如果没有对整数溢出有很深入的理解估计看不出来。

该函数的目的是从包中提取域名，并将其复制到nameStr字符串中。其中count是可控的signed char 类型的值，范围是[-128,127]。假设index的第一个字节被放置为-1，那么根据算术类型转换规则，count将进行符号扩展，依然是-1，strlen返回的是size_t，32位机器中，这是一个unsigned int类型。

下面是**sakura师傅**的讲解：

>  假如这个循环已经进行了一次，并且strlen(nameStr)是5，而count是-1。对于加法，count会被转换为无符号整数，也就是(5+4,294,967,295)，这将造成算术溢出然后得到一个小的值4，而4小于(MAX_LEN-1)，也就是255。
> 接下来，你会看到count（值被你设为-1）被传入strncat()里，strncat()函数取的是size_t，因此这个值会被解释为4,294,967,295，可以将足够多的任意字符写入nameStr字符串中，造成溢出。

从上面的分析可以看出漏洞的关键在于必须循环过一次使得strlen不为0，同时，char是有符号的，所以修复的关键就在于这里了：

~~~c
unsigned char *indx;
unsigned int count;
unsigned char nameStr[MAX_LEN]; //256
...
memset(nameStr, '\0', sizeof(nameStr));
...
indx = (char *)(pkt + rr_offset);
count = (char)*indx;
while (count){
    if (strlen(nameStr) + count < ( MAX_LEN - 1) ){
        indx++;
        strncat(nameStr, indx, count);
        indx += count;
        count = *indx;//!这里开始不再使用char类型，而是使用unsigned char
        strncat(nameStr, ".", sizeof(nameStr) - strlen(nameStr));
    } else {
        fprintf(stderr, "Alert! Someone is attempting "
        "to send LONG DNS packets\n");
        count = 0;
    }
}
nameStr[strlen(nameStr)-1] = '\0';
~~~

Case3:

~~~c
unsigned short read_length(int sockfd) {
    unsigned short len;
    if(full_read(sockfd, (void *)&len, 2) != 2)
        die("could not read length!\n");
    return ntohs(len);
}
...
int read_packet(int sockfd) {
    struct header hdr;
    short length;
    char *buffer;
    length = read_length(sockfd);
    if(length > 1024){
        error("read_packet: length too large: %d\n", length); 
        return 1;
    }
    buffer = (char *)malloc(length+1);
    if((n = read(sockfd, buffer, length) < 0){
        error("read: %m");
        free(buffer);
        return 1;
    }
    buffer[n] = '\0';
    return 0; 
}
~~~

这个就比较明显了，首先read_length()函数的结果是unsigned short int，然后length变量是signed short的，那么，在转换过程中必然存在符号转化问题，同时在 if(length > 1024)的时候，两边进行整数提升为int，如果length为负数的话，那条件必然过了，malloc()函数里面也是同样的原理，如果length的值设为0xFFFF，符号位扩展后就是0xFFFFFFF。这个值加1会环绕到0，然后malloc(0)返回一个非常小的内存。

但是read函数里面的length是size_t，那么必然造成溢出。

来自sakura师傅的审计技巧：

> 在寻找与符号位扩展相关的漏洞时，你应该关注处理signed character values或者pointers 和 signed short integer values 或者 pointers的代码。
> 通常，你可以在字符串处理代码和对带有长度的数据包进行解码的网络代码中找到它们。
>
> 通常，你希望查找**具有char或short整数类型的代码，并将其转换为整数的使用它**
>
> **记住，如果看到signed char或signed short转换为unsigned，符号位扩展也会发生。**
>
> 如前所述，查找符号位扩展漏洞的一种有效方法是搜索movsx指令的汇编代码。在搜索代码中可能存在漏洞的位置时，这种技术通常可以帮助你穿越typedef、宏和类型转换等多个层面的干扰。
>

## 截断

​	截断通常发生在大类型转化为小类型的时候，但是算术转换和证书提升实际上从未要求将大类型转换为小类型。

**截断只能在赋值，类型转换或者函数调用时发生，这里有一个截断的简单例子：**

~~~c
int g = 0x12345678;
short int h;
h = g;
~~~

~~~c
void assume_privs(unsigned short uid)
{
    seteuid(uid);
    setuid(uid);
}
int become_user(int uid)
{
    if (uid == 0)
	    die("root isnt allowed");
    assume_privs(uid);
}
~~~

~~~c
unsigned short int f;
char mybuf[1024];
char *userstr=getuserstr();

f=strlen(userstr);
if (f > sizeof(mybuf)-5)
	die("string too long!");
strcpy(mybuf, userstr);
~~~

> 审计思路
> 当整数值被分配给较小的数据类型(如short整数类型或字符)时，通常会发现与截断相关的漏洞。

## 比较

Case1:

~~~c
#define MAX_SIZE 1024
int read_packet(int sockfd) {
    short length;
    char buf[MAX_SIZE];
    length = network_get_short(sockfd);
    if(length - sizeof(short) <= 0 || length > MAX_SIZE){ 
        error("bad length supplied\n");
        return 1;
    }
    if(read(sockfd, buf, length - sizeof(short)) < 0){ 
        error("read: %m\n");
        return 1;
    }
    return 0; 
}
~~~

从网路中拿到一个short类型的值，但是在length - sizeof(short)的过程中，因为sizeof的返回值是size_t，那么length经过整数提升和算术转换会成为一个unsigned int的值，减法的最终结果是无符号整数，那么必然不可能小于0，那么比如输入0xffff，对于第二个判断因为这个是负数所以必然成功，但是在read的时候，函数中的参数是size_t类型，其再次被转化为unsigned int类型，这就导致可以读入一个很大的长度进而造成整数溢出。

> 可以提供多个值以规避这两个检查并触发缓冲区溢出。如果length是一个负数，例如0xFFFF，那么第一个检查会通过，因为减法的结果类型是无符号的。
>
> 第二个检查(length>MAX_SIZE)仍然会通过，因为length在比较时是一个signed int，并且是个负数，那么它就小于MAX_SIZE(1024)。

Case2:

~~~c
int read_data(int sockfd)
{
    char buf[1024];
    unsigned short max = sizeof(buf);
    short length;
    length = get_network_short(sockfd);
    if(length > max){
        error("bad length: %d\n", length);
        return 1;
    }
    if(read(sockfd, buf, length) < 0){
        error("read: %m");
        return 1;
    }
	... process data ...
	return 0;
}
~~~

在length和max进行比较的时候，他们都被算术转换为signed int 类型，这就意味着，如果我们输入的是负值的话，那么就会绕过长度检查，在read的时候实现溢出。

> 审计技巧
> 检查比较对于审计C代码是必不可少的。特别注意内存分配、数组索引和复制操作前面的比较。
> 检验这些比较的最好方法是逐行仔细研究每个相关的表达式。
>
> 在计算比较时，一定要注意有无符号整数值，以免另一个操作数被提升为无符号整型。sizeof和strlen()是导致这种提升的经典例子，见上面的case1。

## 运算符

### sizeof

Case1:

~~~c
char *read_username(int sockfd)
{
    char *buffer, *style, userstring[1024];
    int i;
    buffer = (char *)malloc(1024);
    if(!buffer){
        error("buffer allocation failed: %m");
        return NULL;
    }
    if(read(sockfd, userstring, sizeof(userstring)-1) <= 0){
        free(buffer);
        error("read failure: %m");
        return NULL;
    }
    userstring[sizeof(userstring)-1] = '\0';
    style = strchr(userstring, ':');
    if(style)
    	*style++ = '\0';
    sprintf(buffer, "username=%.32s", userstring);
    if(style)
    	snprintf(buffer, sizeof(buffer)-strlen(buffer)-1,
    ", style=%s\n", style);
    return buffer;
}
~~~

直觉上`sizeof(buffer)`是获取buffer分配了多少，但是buffer是个指针，所以sizeof的返回值固定是指针的长度。

> 注意sizeof的对象是否是一个内存指针，及其代表的含义，另外也注意sizeof在之前的例子中造成的带符号整数到无符号整数的符号转换。

## 运算顺序和优先级

### 结构体对齐

C结构体的一个有点模糊 的特性是，结构体成员不比在内存中连续地布局。成员的顺序保证遵循指定的顺序，但是可以再成员之间使用填充来对齐。

~~~c
struct bob
{
    int a;
    unsigned short b;
    unsigned char c;
};
~~~

你觉得sizeof(bob)会是什么？从道理上说应该是7，也就是sizeof(a)+sizeof(b)+sizeof(c)，也就是4+2+1。但大多数编译器会返回8因为它们插入了填充进行对齐。











