# 整数溢出

Case1:

~~~c
u_char *make_table(unsigned int width, unsigned int height, u_char *init_row) {
    unsigned int n;
    int i;
    u_char *buf;
    n = width * height; //任意输入两个unsigned int类型的参数，相乘的结果保留在一个unsigned int类型中导致整数溢出
    //计算方式：将width设置为0x400，height设置为0x1000001，相乘后溢出得到1024，0x400000400%(2**32)=1024
    buf = (char *)malloc(n);
    if (!buf) {
        return NULL;
    }
    for (int j = 0; j < height; ++j) {
        memcpy(&buf[i*width], init_row, width);
    }
    return buf;
}
~~~

Case2:

~~~c
u_int nresp; 
...
nresp = packet_get_int(); 
if (nresp > 0) {
    response = xmalloc(nresp * sizeof(char*));//如果将nresp的值设置的足够大，就会产生溢出，进而malloc一个较小的值。 
    for (i = 0; i < nresp; i++)
        response[i] = packet_get_string(NULL); 
packet_check_eom();
~~~

## 减法下溢

~~~
unsigned int a; 
a=0x10;
a-=0x30;
~~~

~~~
0000 0000 0000 0000 0000 0000 0001 0000 - 
0000 0000 0000 0000 0000 0000 0011 0000 = 
1111 1111 1111 1111 1111 1111 1110 0000
~~~

这就导致结果为0xffffffe0.

Case1:

~~~c
struct header {
	unsigned int length;
	unsigned int message_type;
};
char *read_packet(int sockfd)
{
	int n;
	unsigned int length;
	struct header hdr;
	static char buffer[1024];
	if(full_read(sockfd, (void *)&hdr, sizeof(hdr))<=0){
		error("full_read: %m");
		return NULL;
	}
	length = ntohl(hdr.length);//意味着从网络端接收length长度
	if(length > (1024 + sizeof(struct header) - 1)){
        error("not enough room in buffer\n");
		return NULL;
	}
	if(full_read(sockfd, buffer,
			length-sizeof(struct header))<=0) //如果之前的length长度被设置为很小的值，那么此时的减法下溢就可能导致该结果产生一个很大的值。
	{
		error("read: %m");
		return NULL;
	}
	buffer[sizeof(buffer)-1] = '\0';
	return strdup(buffer);
}
~~~

## 带符号整数边界

带符号整数的溢出一般来源于符号位的变化。

例如将一个正数溢出到0x80000000以上来变成一个负数，或者将一个负数溢出到0x80000000以下来变成一个正数，从而突破符号边界。

Case1:

~~~c
#define MAXCHARS 1024
char *read_data(int sockfd)
{
    char *buf;
	int length = network_get_int(sockfd);
	if(!(buf = (char *)malloc(MAXCHARS)))
		die("malloc");
	if(length < 0 || length + 1 >= MAXCHARS){
		free(buf);
        die("bad length");
	}
	if(read(sockfd, buf, length) <= 0){
            free(buf);
            die("read");
	}
	return buf;
}
~~~

该case中length可由网络获得，如果其被设置为0x7fffffff，那么length < 0可绕过，同时length + 1也可以绕过，因为0x7fffffff+1=0x80000000，导致其变成了一个负数。但是下面的read系统调用的length是一个无符号整数，这就导致有了一个几乎不限制长度的输入。

Case2:openssl 0.9.6

~~~c
c.inf=ASN1_get_object(&(c.p),&(c.slen),&(c.tag),&(c.xclass), len-off);
...
{
    /* suck in c.slen bytes of data */ 
    want=(int)c.slen;
    if (want > (len-off))
    {
        want-=(len-off);
        
        if (!BUF_MEM_grow(b,len+want)) {
            ASN1err(ASN1_F_ASN1_D2I_BIO, ERR_R_MALLOC_FAILURE);
            goto err; 
        }
~~~

want是一个有符号整数，len代表的是已经分配的内存，off代表的是已经使用的内存，这段代码的含义在于如果需要的内存大于剩余的内存那么就进行通过BUF_MEM_grow来进行内存分配，这里的关键在于want-(len-off)，但是在下面的代码中出现了want+len，那么如果want=0x7fffffff，len=200，off=50，则在进行加法运算的时候len+want的结果就变成了一个负数，结合BUF_MEM_gouw函数的实现（会将它的长度参数和之前已经分配的空间大小作比较，如果小于，则不会重新进行内存分配。），我们发现会造成内存重分配绕过，进而造成堆溢出。

## 类型转换

### 整数类型：保值

在进行类型转换的过程中，如果新的类型可以表示所有旧类型可能的值，那么这种转换就是保值的。这种情况下，转换的结果不会导致值发生任何变化或丢失。

### 整数类型：扩展

当你将一个较窄类型转换为另一个更宽的类型时，机器会按位将旧的变量复制到新的变量，然后将其他的高位设为0或者1.

* 如果源类型是无符号的，那么就会使用零扩展的方式，将宽类型的剩余高危全部设为0.
* 如果源类型是有符号的，那么就会采用符号位扩展，将宽类型剩余未使用位设为源类型中符号位的值。

### 整数类型：截断

当将一个宽类型转换为窄类型时，机器只会使用一种机器：截断(truncation)。宽类型中与窄类型不匹配的位会被全部舍去。

同时，所有的收缩转换都是变值转换，因为在转换的过程中精度丢失了。

### 整数类型：带符号与无符号

相同宽度的带符号和无符号数之间的转换，在位级别上不会发生变化，但是这样的转换是变值的。

## 算术类型转换规则

1. 浮点优先

## 类型转换漏洞

### signed/Unsigned转换

Case1:

~~~c
int copy(char *dst, char *src, unsigned int len)
{
    while (len--)
    *dst++ = *src++;
}
~~~

如果第三个参数传入的是无符号整数，那么就会导致类型转换

~~~c
int f = -1;
copy(mydst, mysrc, f);
~~~

copy()函数将会得到一个非常大的len。几乎所有的libc例行程序都将大小参数的类型定为size_t，这是一种和指针长度相等的无符号类型。这也是为什么永远不要将一个负长度的参数传入libc函数,例如snprintf(), strncpy(), memcpy(), read(), 或者strncat()

* 审计技巧：函数使用size_t或者unsigned整数作为长度参数，但是参数可以被用户控制，传入一个负值。

  适合review的函数包括read()、recvfrom()、memcpy()、memset()、bcopy()、snprintf()、strncat()、strncpy()和malloc()。如果用户传入一个负值，那么函数会将其解释为一个极大值，可能导致溢出漏洞。

### Sign_Extension

从窄的带符号类型转换为宽的无符号类型，编译器会生成汇编指令执行符号位扩展，对象的值可能会变。

Case1:

~~~c
char len;
len = get_len_field();
snprintf(dst, (unsigned int)len, "%s", src)
~~~

符号位扩展发生在char到unsigned int的类型转换过程中，如果len是一个负值，那么在符号扩展之后len就是一个很大的值。

Case2:

~~~c
char *indx;
int count;
char nameStr[MAX_LEN]; //256
...
memset(nameStr, '\0', sizeof(nameStr)); 
...
indx = (char *)(pkt + rr_offset); 
count = (char)*indx;
while (count){
    if (strlen(nameStr) + count < ( MAX_LEN - 1) ){
        (char *)indx++;
        strncat(nameStr, (char *)indx, count); 
        indx += count;
        count = (char)*indx;
        strncat(nameStr, ".", sizeof(nameStr) - strlen(nameStr));
    } else {
        fprintf(stderr, "Alert! Someone is attempting "
        "to send LONG DNS packets\n");
        count = 0; 
    }
}
nameStr[strlen(nameStr)-1] = '\0';
~~~





















